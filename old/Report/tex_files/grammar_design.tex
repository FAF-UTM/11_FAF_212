%\addcontentsline{toc}{chapter}{Grammar Design}
\chapter{Grammar Design}

In programming languages, grammar refers to a set of rules that define the syntax of the language. The grammar specifies how the language's symbols and keywords can be combined to create valid expressions and statements.

The grammar would be like a set of rules that tells a computer how to understand and analyze medical results. It has different parts that describe different types of results, such as tests, imaging, and lab results.

Each type of result has specific information, like the name of the test, the results themselves, and any units or reference ranges that might be important. The grammar also includes a way for users to ask the computer to show specific sets of results, like all the test results for a particular patient or the average imaging results for a certain time frame.

To make things easier for the user, the grammar includes some special words that represent patient data, like the patient's ID or date of birth. This way, the user can ask the computer to show results for a particular patient without having to type out all of their information every time.

Overall, this grammar helps the computer understand medical results and can provide customized reports based on patient data.

\section{Grammar}
For a \textbf{markup language}, we can define its grammar as follows:

A grammar \(G\) is an ordered quadruple \(G = (V_{N}, V_{T}, P, S)\), where:

\( -V_{N}\) is a finite set of non-terminal symbols

\( -V_{T}\) is a finite set of terminal symbols

\begin{equation}
    V_{N}\cap V_{T} = \varnothing 
\end{equation} 

    \( -P\) is a finite set of production rules
    
\begin{equation}
    P\subseteq\left(V_{N}\cup V_{T}\right)^{\ast }V_{N}\left(V_{N}\cup V_{T}\right)^{\ast }\times\left(V_{N}\cup V_{T}\right)^{\ast }
\end{equation}

\( -S\) is the start symbol

\begin{lstlisting}
V_n = {medical_results, test_result, imaging_result, lab_result, query, query_type, result_type, patient_data, patient_id, birthday, date, test_name, imaging_type, lab_name, result, unit, reference_range, normal_range, high_range, low_range, image_location, location}
\end{lstlisting}

\begin{lstlisting}
V_t = {"test", "imaging", "lab", "show", "for", "all", "average", "tests", "imaging", "labs", "patient", "age", "-", ">", "<", "units", "normal range", "high range", "low range"}
\end{lstlisting}

In a markup language, the terminal symbols represent the actual content of the document or data being marked up. The non-terminal symbols represent the structure or syntax of the markup language itself. \par
The production rules describe how non-terminal symbols can be replaced or expanded into other non-terminal or terminal symbols. These rules define the syntax and structure of the markup language. \par
To specify the grammar representation for the markup language we need to use meta notations:

\begin{table}[H]
\caption{\label{demo-table}Meta Notations}
\centering
\begin{tabular}{|l|l|}
\hline
Symbol                           & Definition                         \\ \hline
\textless{}\textgreater{}        & Non-terminal symbol                \\ \hline
*                                & Zero or more occurrences           \\ \hline
+                                & One or more occurrences            \\ \hline
$\mid$                           & Separates the alternatives symbols \\ \hline
-\textgreater{}                  & Derivation                         \\ \hline
$\sim$                           & Except: any character except       \\ \hline
\textbackslash{}\textbackslash{} & Comment                            \\ \hline
\end{tabular}
\end{table}

\begin{lstlisting}
 P = {  <medical_results> -> <test_result> | <imaging_result> | <lab_result> | <query>
        <test_result> -> "test" <test_name> ":" <result> ["units" <unit>] [<reference_range>]
        <imaging_result> -> "imaging" <imaging_type> ":" <result> ["units" <unit>] [<image_location>]
        <lab_result> -> "lab" <lab_name> ":" <result> ["units" <unit>] [<reference_range>]
        <query> -> "show" <query_type> "for" <patient_data>
        <query_type> -> "all" <result_type> | "average" <result_type> "for" <time_frame>
        <result_type> -> "tests" | "imaging" | "labs"
        <patient_data> -> "patient" <patient_id> | "age" <birthday>
        <patient_id> -> <word>+
        <birthday> -> <date>
        <date> -> <year> "-" <month> "-" <day>
        <year> -> <number>
        <month> -> <number>
        <day> -> <number>
        <test_name> -> <word>+
        <imaging_type> -> <word>+
        <lab_name> -> <word>+
        <result> -> <number>
        <unit> -> <word>+
        <reference_range> -> "normal range" <normal_range> | "high range" <high_range> | "low range" <low_range>
        <normal_range> -> <number> "-" <number> <unit>
        <high_range> -> ">" <number> <unit>
        <low_range> -> "<" <number> <unit>
        <image_location> -> "location" <location>
        <location> -> <word>}
\end{lstlisting}

To use the queries, the user must provide the appropriate patient data, either by patient ID or date of birth. The grammar also includes derived expressions such as \texttt{<patient\_id>} and to simplify the query process.

Overall, this grammar is designed to provide a comprehensive language for analyzing medical results and generating customized reports based on patient data.

An example of code using this grammar representation is:

\begin{lstlisting}
Description { 
	test glucose= 120 
	units= 'mg/dL' 
	stage= 'normal' 
	range= '70-100'
}
Setting {
	patient= 'John Smith', 
	age= '1978-01-01'
	gender= 'male',
	weight= '175 lbs',
	height= '5 11'
}
Response {
    	show all tests for patient age 1978-01-01
   	 // Output: glucose: 120 mg/dL (normal)
}
Response {
    	show average labs for last 6 months for patient John Smith
   	 // Output: No lab results found for patient John Smith in the last 6 months.
}
Response {
    	show all imaging for patient John Smith
   	 // Output: No imaging results found for patient John Smith.
}
Response {
    	length 300 
    	prompt "The patient's glucose test results were higher than normal and indicate the presence of diabetes. The patient is advised to follow up with a healthcare provider for further evaluation and treatment."
}    
\end{lstlisting}

This grammar is like a set of rules for a computer program to understand medical results. It's designed to help doctors and researchers analyze medical data more easily.

In this code, we first define the glucose test result for the patient, specifying the value, units, stage, and reference range. We then define the patient's data, including their name, birthday (derived from age), gender, weight, and height.

We then use the Response section to generate different queries and responses. In the first response, we show all the test results for the patient with the specified birthday, which returns the glucose test result. In the second response, we show the average of all lab results for the patient John Smith in the last 6 months, but since no lab results were provided in the example, the output is "No lab results found." In the third response, we show all the imaging results for the patient John Smith, but since no imaging results were provided in the example, the output is "No imaging results found."

Finally, we provide a response that includes a message about the patient's glucose test result, using the length and prompt keywords to specify the length of the message and the message itself.